---
title: "Diet composition and environmental niche drive parasitic Syndiniales interactions with crustacean zooplankton"
author: "Neea Hanström"
output: word_document
date: "2025-08-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


# Call the packages required for analysis

```{r}
# Clear the environment
rm(list = ls())

library(phyloseq)
library(tidyverse)
library("phyloseq")
library("tidyr")
library("tidyverse")
library("circlize")
library("vegan")
library("ggplot2")
library("vegan")
library("dplyr")
library("FSA")
library(viridis)
library(viridisLite)
library(corrplot)
library(randomForest)


```

# Filter the samples from the dataset we want to keep for this project
```{r}
#Set the directory
setwd("/Users/neea/Documents/Project_1/Data")  

ps_18 <- readRDS("./ps_18S_all.rds") # the original phyloseq object

keep <- c("Spatial19-06", "Spatial20-09", "Seasonal07-08")                      # Define the metadata to keep in a vector
spatial <- subset_samples(ps_18,                                                # In the ps_18 object
                          PROJECT_ID %in% keep)                                 # I want to keep only the project_id that are in the vector "keep"
spatial2 <- subset_samples(spatial,
                           SORTED_genus %in% c("Acartia",                       # and only these taxa
                                               "Temora",
                                               "Centropages",
                                               "Pseudocalanus",
                                               "Evadne",
                                               "NA"))       # NA is the water samples
# List of dates to remove
# Delete samples from March and November
dates_to_remove <- as.Date(c("2017-11-15", "2018-03-19"))

# Remove samples with the specified dates

physeq_filtered <- subset_samples(spatial2, !(as.Date(SAMPLE_date) %in% dates_to_remove))

# Get the number of reads before removing the Crustacean reads
### The total reads per sample

sample_reads <- sample_sums(physeq_filtered)
sample_data_df <- as.data.frame(sample_data(physeq_filtered))

# Combine the data into a single data frame
sample_data_df$Total_Reads <- sample_reads

sample_data_df$Total_Reads%>%
  unique

#Use dplyr to group by Sample type and sum the reads
reads_per_sample_type <- sample_data_df %>%
  group_by(SAMPLE_type) %>%
  summarise(Total_Reads = sum(Total_Reads))

print(reads_per_sample_type)

                                            
# after filtering only the things we want to keep, remove the large phyloseq objects from the environment

rm(ps_18)
rm(keep)
rm(spatial)
```

# As a quality control, remove all the crustacean reads and all the samples with low read count (<500 reads)
Create rarefaction curves for the samples that are left after the filtration as part of the quality control
```{r}
# Remove the crustacean reads from the phyloseq object created above. It includes the samples from the projects "Spatial19-06", "Spatial20-09", "Seasonal07-08" and the hosts chosen above

# Remove the crustacean reads
keep3 <- physeq_filtered %>%                                                        
  subset_taxa(Order != "Crustacea")

# Check the read count before removing the low read samples
sample_data_df <- as.data.frame(sample_data(keep3))

### The total reads per sample
sample_reads <- sample_sums(keep3)

# Combine the data into a single data frame
sample_data_df$Total_Reads <- sample_reads

sample_data_df$Total_Reads%>%
  unique

#Use dplyr to group by Sample type and sum the reads
reads_per_sample_type <- sample_data_df %>%
  group_by(SAMPLE_type) %>%
  summarise(Total_Reads = sum(Total_Reads))

print(reads_per_sample_type)


# Remove samples with read count less than 500. 
filtered_relative <- prune_samples(sample_sums(keep3) >= 500, keep3)


```
# Figure S3, rarefaction curves

```{r}
#Rarefaction curves

library(ranacapa); packageVersion("ranacapa")                         # v. 0.1.0
ggrare(physeq_object = filtered_relative, # <—— your phyloseq object
       parallel = TRUE,
       step = 100,
       color = "SORTED_genus") + # Might be SORTED_genus or similar
  facet_wrap(~SORTED_genus, scales = "free") +
  theme_minimal()

```

# Read count for all the samples

```{r}
sample_data_df <- as.data.frame(sample_data(filtered_relative))

### The total reads per sample
sample_reads <- sample_sums(filtered_relative)

# Combine the data into a single data frame
sample_data_df$Total_Reads <- sample_reads

sample_data_df$Total_Reads%>%
  unique

#Use dplyr to group by Sample type and sum the reads
reads_per_sample_type <- sample_data_df %>%
  group_by(SAMPLE_type) %>%
  summarise(Total_Reads = sum(Total_Reads))

print(reads_per_sample_type)
```

# Read count for Syndiniales

```{r}
# Get the reads of Syndiniales in the water and in the host samples in the "subset" phyloseq object

physeq_subset <- subset_taxa(filtered_relative, Class == "Syndiniales") ### You can change the taxonomic level and the name of the taxa of interest accordingly here

#Put it into a data frame
sample_data_syndiniales <- as.data.frame(sample_data(physeq_subset))

#Extract the OTU/ASV table for the subsetted taxon
otu_table_df <- as.data.frame(otu_table(physeq_subset))

#Calculate the total reads per sample for the subsetted taxon
sample_reads_syndiniales <- sample_sums(physeq_subset)

# Combine sample metadata and sample read counts
sample_data_syndiniales$Total_Reads <- sample_reads_syndiniales

# Summarize the total reads by SampleType using dplyr
library(dplyr)
reads_by_sample_type <- sample_data_syndiniales %>%
  group_by(SAMPLE_type) %>%
  summarise(Total_Reads = sum(Total_Reads))

#### Print the total reads of Syndiniales in water and in the hosts
print(reads_by_sample_type)

# Syndiniales reads per individual sample

sample_data_syndiniales$Total_Reads%>%
  unique
```
# Melt the data from the phyloseq object into a clissical dataframe
- multiple checkups and data structure changes
- adding a column with the relative abundances of the taxa found in each sample
```{r}

# melt the data from a phyloseq object to a dataframe. subset: in "filtered_relative" the crustacean reads have been removed and the samples with 500 or more, and the samples from June to September are kept in this object
data <- filtered_relative %>%
  psmelt() %>%
  filter(STATION_ID != "NA")  # this deletes the samples that are not assigned with a station (sampling error)


# Chech that we have the samplig dates/sations we want 
data$SAMPLE_date %>%
  unique()
# tell R that the sample date is a character
data$SAMPLE_date<-as.character(data$SAMPLE_date) 
# Check the data structure
str(data)

# Chech the number of samples 
num_unique_samples <- length(unique(data$Sample))
print(num_unique_samples)


# Create a column with relative abundance and keep the absolute abundance still in the data

sample_df1 <- data %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done

Water <- sample_df1%>%
  filter(SAMPLE_type == "Water")


# check the number of water samples (56)
num_unique_samples <- length(unique(Water$Sample))
print(num_unique_samples)

```
# Remove some large objects we no longer need
```{r}
rm(physeq_filtered)
rm(physeq_subset)
rm(spatial2)
rm(keep3)
```

# Add a line with taxa of interest; Syndiniales in this case

```{r}

# Add a line with taxa of interest
sample_df <- sample_df1 %>%
  
  unique() %>%   
                                                                                # From the dataset df. The unique() is used to delete duplicate values of the rows present in the data frame
  mutate(Taxa = ifelse(Class == "Syndiniales",                                  # I add a column called Taxa that if it is from the class syndinales
                       as.character(Class),                                     # contains the name of the class (i.e, Syndinales)
                       "Other"),                                                 # otherwise it is called Food
         SORTED_genus = ifelse(SORTED_genus ==  "NA",                           # Same but to replace NA by water
                               "Water",
                               as.character(SORTED_genus)), 
         Location = ifelse(STATION_ID %in% c("BY2", "BY5"),                     #adding a location variable
                           "SBS",
                           ifelse(STATION_ID %in% c("BY15", "BY16"),
                                  "CBS",
                                  ifelse(STATION_ID=="BY31", "BY31", ifelse(STATION_ID == "NA", "Remove", "Marine")))),
         Location = factor(Location,                                            # I transform the location as a factor with different levels, it states the order for plotting
                           levels = c("Marine",
                                      "SBS",
                                      "CBS",
                                      "Remove",
                                      "BY31"))) %>% filter(Location != "Remove")

```

# Visualize tha data with ggplot.
- sample_df is the dataframe now that contains the relative abundance column for all the reads in each sample, and all the information we need to proceed with the analysis
```{r}

# First overview of the data
ggplot(data = sample_df,
       mapping = aes(x = Sample,             
                     y = RelativeAbundance,
                     fill = Supergroup)) +                                           # everything found on the samples on Supergroup level, change for Class level
  
  geom_bar(stat = "identity")
```
# Create the ASV tables to see how many ASVs there are within each location, sample, host etc.

```{r}

# This code can be changed based on the ASVs you are interested in. Change the Orde, Location, SORTDE_genus etc to get the information you want.
ASV_table <- sample_df %>% 
filter(Taxa == "Syndiniales", Abundance > 0) %>%                    #This is to get the asv tables on the syndiniales inside each hots species in each location. Just remove the location variable to get the overall numbers
  group_by(SORTED_genus, Location, Order) %>%                       #Change order to Family to get clade level
  summarise(nasv = n_distinct(OTU)) %>% # sums up the number of distinct OTUs
  pivot_wider(names_from = Order, values_from = nasv)


```
# To check the frequency of occurence: Add a column with Syndiniales presence/absence within a sample
```{r}
# Add a column with Syndiniales taxa present/absent in the sample

all_samples <- sample_df %>%
  
  unique() %>%   
  # From the dataset all_samples. The unique() is used to delete duplicate values of the rows present in the data frame
  mutate(Taxa = ifelse(Class == "Syndiniales",                                  # I add a column called Taxa that if it is from the class syndinales
                       as.character(Class),                                     # contains the name of the class (i.e, Syndinales)
                       "Other"),                                                # otherwise it is called Other
         SORTED_genus = ifelse(SORTED_genus ==  "NA",                           # Same but to replace NA by water
                               "Water",
                               as.character(SORTED_genus)), 
         Location = ifelse(STATION_ID %in% c("BY2", "BY5"),                     #adding a location variable
                           "SBS",
                           ifelse(STATION_ID %in% c("BY15", "BY16"),
                                  "CBS",
                                  ifelse(STATION_ID=="BY31", "BY31", ifelse(STATION_ID == "NA", "Remove", "Marine")))),
         Location = factor(Location,                                            # I transform the location as a factor with different levels, it states the order for plotting
                           levels = c("Marine",
                                      "SBS",
                                      "CBS",
                                      "Remove",
                                      "BY31"))) %>% filter(Location != "Remove")


```

# Figure 1: Plot the water samples 
```{r}
# To average within location, use this:
water <- all_samples %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done


#Plot the community in each sample

water <- water %>% # 
  filter(SORTED_genus == "Water", #Choose only water
         SORTED_genus != "Bosmina")  # remove Bosmina.


# Categorize taxa for color assignment
water <- water %>%
  mutate(Color_Group = case_when(
    # Specific Dino-Groups within Alveolata
    Order %in% c("Dino-Group-I", "Dino-Group-II", "Dino-Group-III", "Dino-Group-IV") ~ Order,
    
    # Other Alveolata taxa
    Supergroup == "Alveolata" ~ "Other Alveolata",
    Supergroup == "Opisthokonta" ~ "Opisthokonta",
    Supergroup == "Rhizaria" ~ "Rhizaria",
    Supergroup == "Stramenopiles" ~ "Stramenopiles",
    
    # The rest of the Supergroups
    TRUE ~ "Other Supergroups"
  ))

water <- water %>%
  mutate(Color_Group = factor(
    Color_Group, 
    levels = c("Other Supergroups", "Opisthokonta", "Rhizaria", "Stramenopiles", "Other Alveolata","Dino-Group-IV", "Dino-Group-III","Dino-Group-II",  "Dino-Group-I" )
  ))



# Custom color palette
colors <- c(
  "Dino-Group-I" = "#99CC99",   # Light green
  "Dino-Group-II" = "#6699FF",  # Light blue
  "Dino-Group-III" = "#330066", # Dark purple
  "Dino-Group-IV" = "#FF6699",  # Pink
  "Other Alveolata" = "moccasin", # Orange for non-Dino Alveolata
  "Other Supergroups" = "#DADADA", # Grey for Other groups groups
  "Opisthokonta" = "grey70",
  "Rhizaria" = "#636363",
  "Stramenopiles" = "#3C3C3C"
)


ggplot(data = water,                                             
       mapping = aes(x = Sample, 
                     y = RelativeAbundance, 
                     fill = Color_Group)) +  # Use Color_Group for coloring
  geom_bar(stat = "identity") +
  facet_grid(. ~ Location,        
             scales = "free_x",
             space = "free") +
  labs(x = NULL,
       y = "Relative abundance") +
  scale_y_continuous(breaks = seq(0, 1, .25)) +
  
  # Apply custom colors
  scale_fill_manual(values = colors) +
  
  # Apply classic theme and adjust x-axis text orientation
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5))

```
# Figure 2: Barplot of the zooplankton
```{r}
# To average within location, use this:
koe <- all_samples %>%
  group_by(SORTED_genus, Location) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done


# Remove water and Bosmina

koe <- koe %>% 
  filter(SORTED_genus != "Water",
         SORTED_genus != "Bosmina")  


# Categorize taxa for color assignment
koe <- koe %>%
  mutate(Color_Group = case_when(
    # Specific Dino-Groups within Alveolata
    Order %in% c("Dino-Group-I", "Dino-Group-II", "Dino-Group-III", "Dino-Group-IV") ~ Order,
    
    # Other Alveolata taxa
    Supergroup == "Alveolata" ~ "Other Alveolata",
    Supergroup == "Opisthokonta" ~ "Opisthokonta",
    Supergroup == "Rhizaria" ~ "Rhizaria",
    Supergroup == "Stramenopiles" ~ "Stramenopiles",
    
    # The rest of the Supergroups
    TRUE ~ "Other Supergroups"
  ))

koe <- koe %>%
  mutate(Color_Group = factor(
    Color_Group, 
    levels = c("Other Supergroups", "Opisthokonta", "Rhizaria", "Stramenopiles", "Other Alveolata","Dino-Group-IV", "Dino-Group-III","Dino-Group-II",  "Dino-Group-I" )
  ))



# Custom color palette
colors <- c(
  "Dino-Group-I" = "#99CC99",   # Light green
  "Dino-Group-II" = "#6699FF",  # Light blue
  "Dino-Group-III" = "#330066", # Dark purple
  "Dino-Group-IV" = "#FF6699",  # Pink
  "Other Alveolata" = "moccasin", # Orange for non-Syndiniales Alveolata
  "Other Supergroups" = "#DADADA", # Grey for Other groups groups
  "Opisthokonta" = "grey70",
  "Rhizaria" = "#636363",
  "Stramenopiles" = "#3C3C3C"
)


ggplot(data = koe,                                             
       mapping = aes(x = SORTED_genus, 
                     y = RelativeAbundance, 
                     fill = Color_Group)) +  # Use Color_Group for colouring
  geom_bar(stat = "identity") +
  facet_grid(. ~ Location,        
             scales = "free_x",
             space = "free") +
  labs(x = NULL,
       y = "Relative abundance") +
  scale_y_continuous(breaks = seq(0, 1, .25)) +
  
  # Apply custom colours
  scale_fill_manual(values = colors) +
  
  # Apply classic theme and adjust x-axis text orientation
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5))


```


# Figure 3: Heatmap of the occurrence of the Syndiniales clades in the samples
```{r}

# Keeping only the samples that have Syndiniales
syndi_pres <- all_samples %>%
  filter(Class == "Syndiniales")


# Add relative abundance column of Syndiniales
all_syndiniales <- syndi_pres %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done
 

# Keeping only the columns we want to keep
syndi_data <- all_syndiniales[ , c("Sample", "Abundance", "RelativeAbundance", "SORTED_genus", "SAMPLE_strata", "Family", "STATION_ID", "Location", "OTU")]

syndi_data <- syndi_data %>% 
  mutate(PresenceAbsence = ifelse(Abundance > 0 , 1, 0)) # If the abundance of a clade is more than 0, the OTU is present (1), otherwise it is 0

# Calculate frequency of occurrence for each clade within each host and water
frequency_data <- syndi_data %>% group_by(Sample, Family, SAMPLE_strata, SORTED_genus, Location) %>% # Change the plotting level by changing the Family to OTU
  summarise(Value = sum(Abundance)) %>% ungroup() %>% 
  filter(SORTED_genus != "Bosmina")%>% # Remove Bosmina
  mutate(PresenceAbsence = ifelse(Value > 0, 1, 0)) %>%
  group_by(Family, SORTED_genus, Location)%>%
  summarise(Frequency = sum(PresenceAbsence) / n_distinct(Sample))

# Ordering of Family levels
custom_order <- c("Dino-Group-I_X", "Dino-Group-I-Clade-1", "Dino-Group-I-Clade-3", "Dino-Group-I-Clade-4", "Dino-Group-I-Clade-5", "Dino-Group-I-Clade-6","Dino-Group-I-Clade-8",
                  "Dino-Group-II_X", "Dino-Group-IIx", "Dino-Group-II-Clade-1", "Dino-Group-II-Clade-2", "Dino-Group-II-Clade-3", "Dino-Group-II-Clade-4", "Dino-Group-II-Clade-5", "Dino-Group-II-Clade-6",
                  "Dino-Group-II-Clade-8", "Dino-Group-II-Clade-10-and-11", "Dino-Group-II-Clade-12", "Dino-Group-II-Clade-13", "Dino-Group-II-Clade-14", "Dino-Group-II-Clade-16", "Dino-Group-II-Clade-17", "Dino-Group-II-Clade-19",
                  "Dino-Group-II-Clade-20", "Dino-Group-II-Clade-22", "Dino-Group-II-Clade-23", "Dino-Group-II-Clade-25", "Dino-Group-II-Clade-26", "Dino-Group-II-Clade-27", "Dino-Group-II-Clade-28", "Dino-Group-II-Clade-30",
                  "Dino-Group-II-Clade-32", "Dino-Group-II-Clade-33", "Dino-Group-II-Clade-38", "Dino-Group-II-Clade-39", "Dino-Group-II-Clade-44", "Dino-Group-II-Clade-46", "Dino-Group-II-Clade-47", "Dino-Group-II-Clade-56",
                  "Dino-Group-II-Clade-57", "Dino-Group-III_X", "Dino-Group-IV-Syndinium-Group", "Dino-Group-IV-Hematodinium-Group")  # Replace with desired order

frequency_data$Family <- factor(frequency_data$Family, levels = custom_order)


frequency_data %>% group_by(Family, Frequency, SORTED_genus, Location) %>% 
  summarise(Value = sum(Frequency)) %>% ungroup() %>% 
  mutate(Presence = ifelse(Frequency > 0, T, F)) %>% # if abundance is >0, the given value is 1, otherwise it is 0
  ggplot(aes(SORTED_genus, Family, fill = as.numeric(Frequency)))+
  geom_tile()+
  theme(axis.text.y = element_blank()) +
  scale_fill_viridis_c(option = "mako", name = "Frequency of 
occurrence (%)",
                       direction = -1,  # Light = low, dark = high
                       begin = 0, end = 1)  +
  facet_grid(~ Location, scales = "free", space = "free") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 14),
        axis.text.y = element_text(size = 12))


```
# Figure 4: Circle plot on Syndiniales Clade level, make the dataframe
```{r}
# Extract Syndiniales
Syndiniales <- all_samples %>%
  filter(Class == "Syndiniales")
Syndiniales <- Syndiniales %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done

# Remove water and Bosmina
mydata <- Syndiniales %>%
  filter(Abundance > 0,
         SORTED_genus != "Water",
         SORTED_genus != "Bosmina")


rel_abw <- mydata %>%
  dplyr::select(Location, Supergroup, Class, Order, Family, SORTED_genus, RelativeAbundance, Sample) %>% 
  mutate(
    TaxonomicLevel = ifelse(
      Class != "Syndiniales",  # If the class is not syndiniales, use class level in taxonomy 
      Class, Family                  # For Syndiniales, use Family level
      
    )
  ) %>% 
  group_by(Sample, TaxonomicLevel, SORTED_genus, Location) %>%
  summarise(RelativeAbundance = sum(RelativeAbundance)) %>% 
  ungroup() %>%
  group_by(Location, SORTED_genus) %>%
  mutate(rep = length(unique(Sample))) %>%
  ungroup() %>%
  group_by(TaxonomicLevel, SORTED_genus, Location, rep) %>%
  summarise(ab = sum(RelativeAbundance)) %>%
  mutate(rel_ab = ab / rep) %>%
  dplyr::select(TaxonomicLevel, SORTED_genus, Location, rel_ab) %>%
  spread(SORTED_genus, rel_ab) %>% 
  as.data.frame() %>%
  ungroup()


```
# Figure 4: Marine
```{r}
###_____________MARINE_____________###

# Filter data for MARINE location and rename taxa
Marine_data <- rel_abw %>%
  filter(Location == "Marine") %>%   # Select Marine location
  select(-Location) %>%           # Remove Location column
  mutate(
    TaxonomicLevel = case_when(
      TaxonomicLevel == "Dino-Group-I-Clade-1" ~ "G1C1",
      TaxonomicLevel == "Dino-Group-I-Clade-3" ~ "G1C3",
      TaxonomicLevel == "Dino-Group-I-Clade-4" ~ "G1C4",
      TaxonomicLevel == "Dino-Group-II-Clade-1" ~ "G2C1",
      TaxonomicLevel == "Dino-Group-II-Clade-32" ~ "G2C32",
      TaxonomicLevel == "Dino-Group-II-Clade-4" ~ "G2C4",
      TaxonomicLevel == "Dino-Group-IIx" ~ "G2X",
      TaxonomicLevel == "Dino-Group-IV-Hematodinium-Group" ~ "G4He",
      TaxonomicLevel == "Dino-Group-IV-Syndinium-Group" ~ "G4Syn",
      TRUE ~ TaxonomicLevel  # Leave other taxa unchanged
    )
  )

# Convert to a matrix for chordDiagram
Marine_matrix <- Marine_data %>%
  column_to_rownames("TaxonomicLevel") %>%  # Use TaxonomicLevel as rownames
  as.matrix()

# Find the index of the column named "Evadne" to plot Evadne last (on the right)
evadne_index <- which(colnames(Marine_matrix) == "Evadne")

# Reorder columns to move "Evadne" to the end
mat <- Marine_matrix[, c(setdiff(seq_len(ncol(Marine_matrix)), evadne_index), evadne_index)]

# Display the updated matrix
print(mat)

Marine_matrix <- mat

# Define colors for renamed taxa 
grid.col = c(
  "G1C1" = "#99CC00", "G1C3" = "forestgreen", "G1C4" = "#99CC99",
  "G2C1" = "#99CCFF", "G2C32" = "#66CCFF", "G2C4" = "#6666FF",
  "G2X" = "#0066CC", "G4He" = "#FF0099", "G4Syn" = "tomato", # Specific taxa colors
  "Acartia" = "#FF9900", "Centropages" = "#FF9900", "Pseudocalanus" = "#FF9900",
  "Temora" = "#FF9900", "Evadne" = "#CC6633"
)


# Clear previous plot settings to ensure a fresh start
circos.clear()

# Set the gap degree and other parameters to improve the plot
circos.par(
  gap.degree = 1,  # Set the space between sectors
  gap.after = c(Marine = 2)  # Adjust specific gap size
)


# Create chord diagram
chordDiagram(
  Marine_matrix,
  grid.col = grid.col,
  annotationTrack = c("grid", "name"), title("Marine"))


```

# Figure 4: SBS
```{r}

###_____________SBS_____________###

SBS_data <- rel_abw %>%
  filter(Location == "SBS") %>%   # Select SBS location
  select(-Location) %>%           # Remove Location column
  mutate(
    TaxonomicLevel = case_when(
      TaxonomicLevel == "Dino-Group-I-Clade-1" ~ "G1C1",
      TaxonomicLevel == "Dino-Group-I-Clade-3" ~ "G1C3",
      TaxonomicLevel == "Dino-Group-I-Clade-4" ~ "G1C4",
      TaxonomicLevel == "Dino-Group-II-Clade-1" ~ "G2C1",
      TaxonomicLevel == "Dino-Group-II-Clade-32" ~ "G2C32",
      TaxonomicLevel == "Dino-Group-II-Clade-4" ~ "G2C4",
      TaxonomicLevel == "Dino-Group-IIx" ~ "G2X",
      TaxonomicLevel == "Dino-Group-IV-Hematodinium-Group" ~ "G4He",
      TaxonomicLevel == "Dino-Group-IV-Syndinium-Group" ~ "G4Syn",
      TRUE ~ TaxonomicLevel  # Leave other taxa unchanged
    )
  )

# Convert to a matrix for chordDiagram
SBS_matrix <- SBS_data %>%
  column_to_rownames("TaxonomicLevel") %>%  # Use TaxonomicLevel as rownames
  as.matrix()

# Find the index of the column named "Evadne"
evadne_index <- which(colnames(SBS_matrix) == "Evadne")

# Reorder columns to move "Evadne" to the end
mat <- SBS_matrix[, c(setdiff(seq_len(ncol(SBS_matrix)), evadne_index), evadne_index)]

# Display the updated matrix
print(mat)

SBS_matrix <- mat

# Define colors for renamed taxa 
grid.col = c(
  "G1C1" = "#99CC00", "G1C3" = "forestgreen", "G1C4" = "#99CC99",
  "G2C1" = "#99CCFF", "G2C32" = "#66CCFF", "G2C4" = "#6666FF",
  "G2X" = "#0066CC", "G4He" = "#FF0099", "G4Syn" = "tomato", # Specific taxa colors
  "Acartia" = "#FF9900", "Centropages" = "#FF9900", "Pseudocalanus" = "#FF9900",
  "Temora" = "#FF9900", "Evadne" = "#CC6633"
)


# Clear previous plot settings to ensure a fresh start
circos.clear()

# Set the gap degree and other parameters to improve the plot
circos.par(
  gap.degree = 1,  # Set the space between sectors
  gap.after = c(SBS = 2)  # Adjust specific gap size
)

# Create a plot
chordDiagram(
  SBS_matrix,
  grid.col = grid.col,
  annotationTrack = c("grid", "name"), title("SBS"))

```
# Figure 4: CBS
```{r}

###_____________CBS_____________###

CBS_data <- rel_abw %>%
  filter(Location == "CBS") %>%   # Select CBS location
  select(-Location) %>%           # Remove Location column
  mutate(
    TaxonomicLevel = case_when(
      TaxonomicLevel == "Dino-Group-I-Clade-1" ~ "G1C1",
      TaxonomicLevel == "Dino-Group-I-Clade-3" ~ "G1C3",
      TaxonomicLevel == "Dino-Group-I-Clade-4" ~ "G1C4",
      TaxonomicLevel == "Dino-Group-II-Clade-1" ~ "G2C1",
      TaxonomicLevel == "Dino-Group-II-Clade-32" ~ "G2C32",
      TaxonomicLevel == "Dino-Group-II-Clade-4" ~ "G2C4",
      TaxonomicLevel == "Dino-Group-IIx" ~ "G2X",
      TaxonomicLevel == "Dino-Group-IV-Hematodinium-Group" ~ "G4He",
      TaxonomicLevel == "Dino-Group-IV-Syndinium-Group" ~ "G4Syn",
      TRUE ~ TaxonomicLevel  # Leave other taxa unchanged
    )
  )

# Convert to a matrix for chordDiagram
CBS_matrix <- CBS_data %>%
  column_to_rownames("TaxonomicLevel") %>%  # Use TaxonomicLevel as rownames
  as.matrix()

# Find the index of the column named "Evadne"
evadne_index <- which(colnames(CBS_matrix) == "Evadne")

# Reorder columns to move "Evadne" to the end
mat <- CBS_matrix[, c(setdiff(seq_len(ncol(CBS_matrix)), evadne_index), evadne_index)]

# Display the updated matrix
print(mat)

CBS_matrix <- mat


# Define colours
grid.col = c(
  "G1C1" = "#99CC00", "G1C3" = "forestgreen", "G1C4" = "#99CC99",
  "G2C1" = "#99CCFF", "G2C32" = "#66CCFF", "G2C4" = "#6666FF",
  "G2X" = "#0066CC", "G4He" = "#FF0099", "G4Syn" = "tomato", # Specific taxa colors
  "Acartia" = "#FF9900", "Centropages" = "#FF9900", "Pseudocalanus" = "#FF9900",
  "Temora" = "#FF9900", "Evadne" = "#CC6633"
)


# Clear previous plot settings to ensure a fresh start
circos.clear()

# Set the gap degree and other parameters to improve the plot
circos.par(
  gap.degree = 1,  # Set the space between sectors
  gap.after = c(CBS = 2)  # Adjust for specific gap size
)

# Create a plot
chordDiagram(
  CBS_matrix,
  grid.col = grid.col,
  annotationTrack = c("grid", "name"), title("CBS"))

```
# Figure 4: BY31
```{r}

###_____________BY31_____________###

BY31_data <- rel_abw %>%
  filter(Location == "BY31") %>%   # Select BY31 location
  select(-Location) %>%           # Remove Location column
  mutate(
    TaxonomicLevel = case_when(
      TaxonomicLevel == "Dino-Group-I-Clade-1" ~ "G1C1",
      TaxonomicLevel == "Dino-Group-I-Clade-3" ~ "G1C3",
      TaxonomicLevel == "Dino-Group-I-Clade-4" ~ "G1C4",
      TaxonomicLevel == "Dino-Group-II-Clade-1" ~ "G2C1",
      TaxonomicLevel == "Dino-Group-II-Clade-32" ~ "G2C32",
      TaxonomicLevel == "Dino-Group-II-Clade-47" ~ "G2C47",
      TaxonomicLevel == "Dino-Group-II-Clade-4" ~ "G2C4",
      TaxonomicLevel == "Dino-Group-IIx" ~ "G2X",
      TaxonomicLevel == "Dino-Group-IV-Hematodinium-Group" ~ "G4He",
      TaxonomicLevel == "Dino-Group-IV-Syndinium-Group" ~ "G4Syn",
      TRUE ~ TaxonomicLevel  # Leave other taxa unchanged
    )
  )

#
# Convert to a matrix for chordDiagram
BY31_matrix <- BY31_data %>%
  column_to_rownames("TaxonomicLevel") %>%  # Use TaxonomicLevel as rownames
  as.matrix()

# Find the index of the column named "Evadne"
evadne_index <- which(colnames(BY31_matrix) == "Evadne")

# Reorder columns to move "Evadne" to the end
mat <- BY31_matrix[, c(setdiff(seq_len(ncol(BY31_matrix)), evadne_index), evadne_index)]

# Display the updated matrix
print(mat)

BY31_matrix <- mat


# Define colour
grid.col = c(
  "G1C1" = "#99CC00", "G1C3" = "forestgreen", "G1C4" = "#99CC99",
  "G2C1" = "#99CCFF", "G2C32" = "#66CCFF", "G2C4" = "#6666FF", "G2C47" = "#66CCCF",
  "G2X" = "#0066CC", "G4He" = "#FF0099", "G4Syn" = "tomato", # Specific taxa colors
  "Acartia" = "#FF9900", "Centropages" = "#FF9900", "Pseudocalanus" = "#FF9900",
  "Temora" = "#FF9900", "Evadne" = "#CC6633"
)


# Clear previous plot settings to ensure a fresh start
circos.clear()

# Set the gap degree and other parameters to improve the plot
circos.par(
  gap.degree = 1,  # Set the space between sectors
  gap.after = c(BY31 = 2)  
)


#Plot it
chordDiagram(
  BY31_matrix,
  grid.col = grid.col,
  annotationTrack = c("grid", "name"), title("BY31"))

```
# Adding the abiotic data into analysis
```{r}
setwd("/Users/neea/Documents/Project_1/Data")
abiotic_26march24 <- readRDS("./abiotic_26march24.rds")

sorting <- filter(abiotic_26march24,                                   # <- In the original object containing the abiotic factors
                  as.numeric(visit_year) %in% c(2019, 2017, 2020, 2018), 
                  station_name %in% c("BY31 LANDSORTSDJ","BY16", "BY15 GOTLANDSDJ", "BY5 BORNHOLMSDJ", "Å17","BY2 ARKONA", "SLÄGGÖ"),
                  sampling_laboratory_code_phyche %in% c("Stockholms universitet", "Sveriges meteorologiska och hydrologiska institut"),
                  parameter %in% c("Salinity CTD", "Temperature CTD", "Chlorophyll-a bottle", "Dissolved oxygen O2 CTD"))                    

unique(sorting$parameter)

sorting %>% group_by(parameter) %>% summarise(unique(unit))                # checking that the salinity has only one kind of unit that is used


# Surface 
abiotic_surface <-sorting %>% 
   filter(as.numeric(sample_depth_m) %in% 0:30)              # filtering out only depths from 0 to 30
  
abiotic_surface$sample_depth_m%>%
  unique()

# Medium
abiotic_medium <-sorting %>% 
   filter(as.numeric(sample_depth_m) %in% 30:60)             # filtering out only depths from 30 to 60

  abiotic_medium$sample_depth_m%>%
  unique()

# Deep
abiotic_deep <-sorting %>% 
  filter(as.numeric(sample_depth_m) %in% 60:90)             # filtering out only depths from 60 to 90
  
abiotic_deep$sample_depth_m%>%
  unique()

# Keeping only the summer months

# Surface
months <- filter(abiotic_surface,
                 as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months$SAMPLE_strata <- "Surface"
dfmonths <-  as.data.frame(months)

months$visit_month%>%
  unique()

# Medium

months_medium <- filter(abiotic_medium,
                        as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months_medium$SAMPLE_strata <- "Medium"
dfmonths_medium <-  as.data.frame(months_medium)

# Deep

months_deep <- filter(abiotic_deep,
                      as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months_deep$SAMPLE_strata <- "Deep"
dfmonths_deep <-  as.data.frame(months_deep)

str(dfmonths_deep)

# Stack the data frames row-wise
combined_depths <- rbind(dfmonths, dfmonths_medium, dfmonths_deep)

##### In the data file combined_depths we have the abiotic factors from the right sampling strata, year and sampling month as
##### we have the zooplankton from. The values are original values, not averages.

# Changing the names of the months from numbers to the month names in the abiotic dataset

dfmonths2 <- combined_depths %>%
  mutate(Season = ifelse(visit_month == "05", "May",                            #Changing the names of the months from numbers to the month names in the abiotic dataset
                         ifelse(visit_month == "06", "June",
                                ifelse(visit_month == "07", "July",
                                       ifelse(visit_month == "08", "August",
                                              ifelse(visit_month == "09", "September", "Other"))))))

# Check the names of the stations to add the STATION_ID column correctly
dfmonths$station_name%>%
  unique()

# Adding the STATION_ID column to the data
dfab1 <- dfmonths2 %>% 
  
  mutate(STATION_ID = ifelse(station_name  == "BY2 ARKONA", "BY2",                 
                             ifelse(station_name == "BY5 BORNHOLMSDJ", "BY5",        #Changing the location names in the abiotic dataset   
                                    ifelse(station_name == "BY15 GOTLANDSDJ","BY15",
                                           ifelse(station_name == "SLÄGGÖ","SLAGGO",
                                                  ifelse(station_name == "BY31 LANDSORTSDJ", "BY31",
                                                         ifelse(station_name == "Å17", "A17",
                                                                "Other")))))))

# Adding the Location column to the data
dfab <- dfab1 %>% 
  
  mutate(Location = ifelse(STATION_ID  == "BY2", "SBS",                 
                           ifelse(STATION_ID == "BY5", "SBS",        #Changing the location names in the abiotic dataset   
                                  ifelse(STATION_ID == "BY15","CBS",
                                         ifelse(STATION_ID == "BY31", "BY31",
                                                ifelse(STATION_ID =="SLAGGO", "Marine", 
                                                       ifelse(STATION_ID =="A17","Marine", 
                                                              "Other")))))))

dfab$sample_depth_m

dfab$sample_depth_m <- as.numeric(as.character(dfab$sample_depth_m))


```

# Merge the abiotic data with the 18S data
```{r}

# Calculating the average abiotic parameter values for the corresponding zooplankton samples, depth, month, year, and location

# Surface 
avg_abiotic<-sorting %>% 
  group_by(visit_month, visit_year, station_name, sample_depth_m, parameter) %>%
  summarise(average = mean(as.numeric(value))) %>%
  ungroup()  %>% filter(as.numeric(sample_depth_m) %in% 0:30) %>%              # filtering out only depths from 0 to 30
  
  group_by(visit_month, visit_year, station_name, parameter) %>%
  summarise(average = mean(as.numeric(average)))

avg_abiotic$visit_year%>%
  unique()

# Medium
avg_medium <-sorting %>% 
  group_by(visit_month, visit_year, station_name, sample_depth_m, parameter) %>%
  summarise(average = mean(as.numeric(value))) %>%
  ungroup()  %>% filter(as.numeric(sample_depth_m) %in% 30:60) %>%              # filtering out only depths from 30 to 60
  
  group_by(visit_month, visit_year, station_name, parameter) %>%
  summarise(average = mean(as.numeric(average)))

# Deep
avg_deep <-sorting %>% 
  group_by(visit_month, visit_year, station_name, sample_depth_m, parameter) %>%
  summarise(average = mean(as.numeric(value))) %>%
  ungroup()  %>% filter(as.numeric(sample_depth_m) %in% 60:90) %>%              # filtering out only depths from 60 to 90
  
  group_by(visit_month, visit_year, station_name, parameter) %>%
  summarise(average = mean(as.numeric(average)))

str(sorting)

# Keeping only the summer months

# Surface
months <- filter(avg_abiotic,
                 as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months$SAMPLE_strata <- "Surface"
dfmonths <-  as.data.frame(months)

# Medium

months_medium <- filter(avg_medium,
                        as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months_medium$SAMPLE_strata <- "Medium"
dfmonths_medium <-  as.data.frame(months_medium)

# Deep

months_deep <- filter(avg_deep,
                      as.numeric(visit_month) %in% c(05, 06, 07, 08, 09))           #average of the parameters, from May to September
months_deep$SAMPLE_strata <- "Deep"
dfmonths_deep <-  as.data.frame(months_deep)

str(dfmonths_deep)

# Stack the data frames row-wise
combined_depths2 <- rbind(dfmonths, dfmonths_medium, dfmonths_deep)

# Changing the names of the months from numbers to the month names in the abiotic dataset to match the zooplankton data

dfmonths2 <- combined_depths2 %>%
  mutate(Season = ifelse(visit_month == "05", "May",                            #Changing the names of the months from numbers to the month names in the abiotic dataset
                         ifelse(visit_month == "06", "June",
                                ifelse(visit_month == "07", "July",
                                       ifelse(visit_month == "08", "August",
                                              ifelse(visit_month == "09", "September", "Other"))))))

# Check the names of the stations to add the STATION_ID column correctly
dfmonths$station_name%>%
  unique()

# Adding the STATION_ID column to the data
dfab1 <- dfmonths2 %>% 
  
  mutate(STATION_ID = ifelse(station_name  == "BY2 ARKONA", "BY2",                 
                             ifelse(station_name == "BY5 BORNHOLMSDJ", "BY5",        #Changing the location names in the abiotic dataset   
                                    ifelse(station_name == "BY15 GOTLANDSDJ","BY15",
                                           ifelse(station_name == "SLÄGGÖ","SLAGGO",
                                                  ifelse(station_name == "BY31 LANDSORTSDJ", "BY31",
                                                         ifelse(station_name == "Å17", "A17",
                                                                "Other")))))))

# Adding the Location column to the data
dfab <- dfab1 %>% 
  
  mutate(Location = ifelse(STATION_ID  == "BY2", "SBS",                 
                           ifelse(STATION_ID == "BY5", "SBS",        #Changing the location names in the abiotic dataset   
                                  ifelse(STATION_ID == "BY15","CBS",
                                         ifelse(STATION_ID == "BY31", "BY31",
                                                ifelse(STATION_ID =="SLAGGO", "Marine", 
                                                       ifelse(STATION_ID =="A17","Marine", 
                                                              "Other")))))))




# Add the visit year and monts to the Syndiniales data to match the abiotic values to correct samples

# Adding the sampling months
syndiseason <- Syndiniales %>%
  mutate(Season = ifelse(SAMPLE_date %in% c("2019-06-01", "2017-06-19", "2019-06-08", "2019-06-07", "2019-06-13", "2019-06-05", "2019-06-12", "2019-06-03", "2019-06-02", "2019-06-06",
                                            "2019-06-11", "2019-06-04", "2017-06-19","2019-06-09"),           
                         "June",                            #Changing the names of the months from numbers to the month names to match abiotic dataset
                         ifelse(SAMPLE_date %in% c("2020-09-07", "2020-09-10", "2020-09-09"),
                                "September",
                                ifelse(SAMPLE_date %in% c("2018-08-27", "2017-08-15"),
                                       "August", "Other"))))


# Adding the visit year

Syndiniales <- syndiseason %>%
  mutate(visit_year = ifelse(SAMPLE_date %in% c("2019-06-01", "2019-06-08", "2019-06-07", "2019-06-13", "2019-06-05", "2019-06-12", "2019-06-03", "2019-06-02", "2019-06-06",
                                            "2019-06-11", "2019-06-04", "2019-06-09", "2019-06-10"),             
                         "2019",                          
                         ifelse(SAMPLE_date %in% c("2020-09-07", "2020-09-10", "2020-09-09"),
                                "2020",
                                ifelse(SAMPLE_date %in% c("2017-08-15", "2017-06-19"),
                                       "2017", 
                                       ifelse(SAMPLE_date %in% c("2018-08-27"), 
                                              "2018", 
                                              "Other")))))
Syndiniales$visit_year%>%
  unique()

# Adding the Location column to the data
Syndiniales <- Syndiniales %>% 
  
  mutate(Location = ifelse(STATION_ID  == "BY2", "SBS",                 
                           ifelse(STATION_ID == "BY5", "SBS",        #Changing the location names in the abiotic dataset   
                                  ifelse(STATION_ID == "BY15","CBS",
                                      ifelse(STATION_ID == "BY16", "CBS",   
                                         ifelse(STATION_ID == "BY31", "BY31",
                                                ifelse(STATION_ID =="SLAGGO", "Marine", 
                                                       ifelse(STATION_ID =="A17","Marine", 
                                                              "Other"))))))))



# To get the relative abundances in each location and host by the Syndiniales groups

rel_ab <- Syndiniales %>%
  dplyr::select(Location, Order, SORTED_genus, Season, visit_year, RelativeAbundance, Sample, STATION_ID, SAMPLE_strata, SAMPLE_date) %>%
  group_by(Sample, Order, SORTED_genus, Season, visit_year, Location, STATION_ID, SAMPLE_strata, SAMPLE_date)%>%
  summarise(RelativeAbundance = sum(RelativeAbundance)) %>% 
  ungroup() %>%
  group_by(Location,Sample, Season, visit_year, SORTED_genus, STATION_ID, SAMPLE_strata, SAMPLE_date)%>%
  mutate(rep = length(unique(Sample)))%>% 
  ungroup()%>%
  group_by(Order, Sample, SORTED_genus, Season, visit_year, STATION_ID, SAMPLE_strata, SAMPLE_date, Location, rep)%>%
  summarise(ab =sum(RelativeAbundance))%>%
  mutate(rel_ab = ab/rep)%>%
  dplyr::select(Order, Sample, SORTED_genus, Season, visit_year, STATION_ID, SAMPLE_strata, SAMPLE_date, Location, rel_ab)%>%
  spread(Order, rel_ab) %>% as.data.frame()


# merge the zooplankton data with the abiotic data

merged_table <- merge(rel_ab, dfab, by = c("Location", "SAMPLE_strata", "visit_year", "STATION_ID", "Season")) # in this file the average of each parameter is the average of each measurement taken in that month. The syndiniales contributions within a host are in relative abundances.


# Pivot wide
wide_merged <- merged_table %>% pivot_wider(names_from = parameter, values_from = average) %>%
  filter(SORTED_genus != "Bosmina")


# Replace the NAs with 0
wide_merged[is.na(wide_merged)] <- 0

# Changing the names of the columns
wide_merged <- wide_merged %>% rename(Salinity = "Salinity CTD")
wide_merged <- wide_merged %>% rename(Temperature = "Temperature CTD")
wide_merged <- wide_merged %>% rename(Chlorophyll = "Chlorophyll-a bottle")
wide_merged <- wide_merged %>% rename(Oxygen = "Dissolved oxygen O2 CTD")


```


# GLM analysis, Table S4
- "wide_merged" contains the 18S data and the corresponding abiotic data

```{r}
data <- wide_merged

# Extract relevant columns (predictor variables)
salinity_data <- data$Salinity
temperature_data <- data$Temperature
chlorophyll_data <- data$Chlorophyll
oxygen_data <-data$Oxygen
sorted_genus <- data$SORTED_genus

# Changing the names of the columns
data <- data %>% rename(SyndiI = "Dino-Group-I")
data <- data %>% rename(SyndiII = "Dino-Group-II")
data <- data %>% rename(SyndiIII = "Dino-Group-III")
data <- data %>% rename(SyndiIV = "Dino-Group-IV")


# Extract the different Dino groups (response variables)
dino_groups <- data[, 9:12]  # the columns with the dino groups

str(dino_groups) # tho check we have all the right groups

# Combine the columns into one data frame
combined_data <- cbind(dino_groups, Salinity = salinity_data, Temperature = temperature_data, Chlorophyll = chlorophyll_data, Oxygen = oxygen_data, Host = sorted_genus)

combined_data $Host %>%
  unique()

# Histogram of one variable (change "Parasite1" to your variable name)
hist(combined_data$SyndiI, main = "Distribution of Parasite1", col = "skyblue")

# Shapiro-Wilk test for normality (p < 0.05 means NOT normal)
shapiro.test(combined_data$SyndiI)

# Fit a GLM for each Dino group with Salinity as the primary predictor
glm_results <- lapply(names(dino_groups), function(group) {
  formula <- as.formula(paste(group, "~ Salinity + Chlorophyll + Temperature + Oxygen"))
  glm(formula, data = combined_data, family = quasipoisson())
})

# Print summaries of the GLM results
glm_summaries <- lapply(glm_results, summary)
names(glm_summaries) <- names(dino_groups)
glm_summaries

```
# Diet analysis: Adding the 16S data
- filtering the 16S phyloseq object and calculting the average relative abundances within a sampling event (season, year, location)
- Combining the different dataframes together

```{r}
# Import the rest of the data as a phyloseq, "ps_16S_all", this contains all the locations and samples 

setwd("/Users/neea/Documents/Project_1/Data")
ps_16S_all <- readRDS("./ps_16S_all.rds")

spatial16 <- subset_samples(ps_16S_all,
                             SORTED_genus %in% c("Acartia",                       # only these taxa
                                                 "Temora",
                                                 "Centropages",
                                                 "Pseudocalanus",
                                                 "Evadne"))       



# List of dates to remove
# Delete samples from March and November
dates_to_remove <- as.Date(c("2017-11-15", "2018-03-19"))

# Remove samples with the specified dates

keep4 <- subset_samples(spatial16, !(as.Date(SAMPLE_date) %in% dates_to_remove))

# melt the data from a phyloseq object to a dataframe. subset: the crustacean reads have been removed and the samples with 500 or more, and the samples from June to September are kept in this object
data16 <- keep4 %>%
  psmelt()   



data16_filt <- data16[ , c("OTU","Sample", "Abundance", "SORTED_genus", "SAMPLE_date", "STATION_ID", "Family", "SAMPLE_strata", "Phylum", "Class", "Order", "Family")]

# Change the STATION_ID to Location
data16_loc <- data16_filt %>%
  
  unique() %>%   
  # From the dataset df. The unique() is used to delete duplicate values of the rows present in the data frame
  mutate(SORTED_genus = ifelse(SORTED_genus ==  "NA",                           # Same but to replace NA by water
                               "Water",
                               as.character(SORTED_genus)), 
         Location = ifelse(STATION_ID %in% c("By2", "By5"),                     #adding a location variable
                           "SBS",
                           ifelse(STATION_ID %in% c("By15", "By16"),
                                  "CBS",
                                  ifelse(STATION_ID=="By31", "BY31", ifelse(STATION_ID == "NA", "Remove", "Marine")))),
         Location = factor(Location,                                            # I transform the location as a factor with different levels, it states the order for plotting
                           levels = c("Marine",
                                      "SBS",
                                      "CBS",
                                      "Remove",
                                      "BY31"))) %>% filter(Location != "Remove")



# check the number of samples
num_unique_samples <- length(unique(data16_loc$Sample))
print(num_unique_samples)


# Assign the diet taxa of interest, the species that belong to Phyloplankton Diet
TypeofPhyto <- c("Diatom", "other Phytoplankton", "other Phytoplankton","other Phytoplankton","Chlorophytes","Filamentous cyanobacteria", "other Phytoplankton",
                 "other Phytoplankton","Picocyanobacteria","Chlorophytes","Chloroplast","Chlorophytes","Diatom","Dinoflagellates","Chlorophytes",
                 "other Phytoplankton","Diatom","Chlorophytes")
OrderofPhyto <- c( "Chaetocerotales",  "Chromulinales",       "Dictyochophyceae_XX", "Eustigmatales",       "Mamiellales",         "Nostocales",         
                   "Ochrophytaxxx",       "Prymnesiales",        "Synechococcales",     "Trebouxiophyceae_XX", "Chloroplastxxxxx",    "Chlorellales",       
                   "Bacillariophytaxx",   "Peridiniales",       "Chlamydomonadales",   "Pyrenomonadales",     "Bacillariophyceaex",  "Pyramimonadales")
Classification <- data.frame(TypeofPhyto,OrderofPhyto)

# Add Orders
prey_order <- c("Chaetocerotales",  "Chromulinales",       "Dictyochophyceae_XX", "Eustigmatales",       "Mamiellales",         "Nostocales",         
                "Ochrophytaxxx",       "Prymnesiales",        "Synechococcales",     "Trebouxiophyceae_XX", "Chloroplastxxxxx",    "Chlorellales",       
                "Bacillariophytaxx",   "Peridiniales",       "Chlamydomonadales",   "Pyrenomonadales",     "Bacillariophyceaex",  "Pyramimonadales")


# JUST keep the rows with any of these
diet_orders <- data16_loc %>%
  filter(Order %in% prey_order)


mydiet_paired <- dplyr::left_join(diet_orders,Classification,by=c("Order"="OrderofPhyto"))

# Create a column with relative abundance and keep the absolute abundance still in the data

diet16 <- mydiet_paired %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done


# Plot the relative abundances
ggplot(data = diet16,
       mapping = aes(x = Sample,             
                     y = RelAbundance,
                     fill = TypeofPhyto)) +
  geom_bar(stat = "identity") +
  facet_grid( ~ Location + SORTED_genus,             
              scales = "free_x",
              space = "free") +
  scale_y_continuous(breaks = seq(0 , 1, .1))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Some samples don't have any data in them, --> remove them

diet16 <- subset(diet16,!Sample%in%c("P15212_4262", "P15212_4267", "P15212_4266", "P15212_4265", "P15212_4257", "P15212_4100", "P15212_4121", "P19201_1104", "P15212_4130","P19201_1132", "P15212_4245", "P19201_1131", "P19201_1107"))
diet16[is.na(diet16)] <- 0


# Calculate the relative abundances for each diet component
diet_relabun <- diet16 %>% 
  dplyr::group_by(Sample) %>%
  dplyr::mutate(Sample_sum = sum(Abundance)) %>% 
  dplyr::mutate(rel_Abundance = Abundance/Sample_sum)

diet_relabun <- diet_relabun %>% 
  dplyr::select(Sample,TypeofPhyto,rel_Abundance, Location, SAMPLE_strata,SORTED_genus) %>%
  dplyr::group_by(Sample,TypeofPhyto) %>% 
  dplyr::mutate(rel_Abundance=sum(rel_Abundance)) %>% 
  unique()

diet_typeofphyto_relabun <- pivot_wider(diet_relabun,
                                        id_cols = Sample,
                                        names_from = TypeofPhyto,
                                        values_from = rel_Abundance
)

mydiet_paired <- dplyr::left_join(diet_orders,Classification,by=c("Order"="OrderofPhyto"))

mydiet_paired$SAMPLE_date%>%
  unique()
# Add sampling season
diet_season <- mydiet_paired %>%
  mutate(Season = ifelse(as.character(SAMPLE_date) %in% c("2019-06-01", "2019-06-19", "2017-06-19"), "June",
                         ifelse(as.character(SAMPLE_date) %in% c("2020-09-07", "2020-09-10", "2020-09-09"), "September",
                                ifelse(as.character(SAMPLE_date) == "2017-08-15", "August", "Other"))))

diet_season$Season%>%
  unique()

# Add the sample year
diet_year <- diet_season %>%
  mutate(visit_year = ifelse(as.character(SAMPLE_date) %in% c("2019-06-01", "2019-06-19"), "2019",
                         ifelse(as.character(SAMPLE_date) %in% c("2020-09-07", "2020-09-10", "2020-09-09"), "2020",
                           ifelse(as.character(SAMPLE_date) %in% c("2017-08-15", "2017-06-19"), "2017", "Other"))))


# Calculate the relative abundance of the diet components and spread by the components
final_df <- diet_year %>%
  select(Location, TypeofPhyto, SORTED_genus, SAMPLE_strata, visit_year, Season, Abundance, Sample) %>%
  # Sum abundance per sample × phyto × genus
  group_by(Sample, TypeofPhyto, SORTED_genus) %>%
  summarise(Abundance = sum(Abundance), .groups = "drop") %>%
  # Compute relative abundance within each sample × genus
  group_by(Sample, SORTED_genus) %>%
  mutate(rel_ab = Abundance / sum(Abundance)) %>%
  ungroup() %>%
  # Bring back metadata for each sample
  left_join(
    diet_year %>%
      distinct(Sample, Location, SAMPLE_strata, visit_year, Season),
    by = "Sample"
  ) %>%
  select(Sample, Location, SAMPLE_strata, visit_year, Season, SORTED_genus, TypeofPhyto, rel_ab) %>%
  spread(TypeofPhyto, rel_ab)

# Calculate the averages of the diet components based on the location, strata, year and sample month to be able to combine the two dataframes
avg_rel_ab <- final_df %>%
  group_by(Location, SAMPLE_strata, visit_year, Season, SORTED_genus) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .groups = "drop")


# Merge the two dataframes: avg_rel_ab and wide_merged by location, sample strata, season and year

wide_final <- wide_merged %>%
  left_join(
    avg_rel_ab,
    by = c("Location", "SAMPLE_strata", "Season", "visit_year", "SORTED_genus")
  )

# Keep only the zooplankton samples for the final diet analysis
zoopl <- wide_final %>%
  filter(SORTED_genus != "Water")

```

# Diet analysis: Adding the 18S diet components
```{r}
# Add phyla
prey_phyla <- c("Ciliophora", "Cercozoa", "Choanoflagellida", 
                "Radiolaria", "Labyrinthulomycetes")

# Add prey classes 
prey_classes <- c("Colpodellida", "Protostomatea", "Spirotrichea", 
                  "Oligohymenophorea", "Dinophyceae")  

# JUST keep the rows with any of these
diet18 <- all_samples %>%
  filter(Phylum %in% prey_phyla | Class %in% prey_classes)

# To make sure no Syndiniales are included, and remove bosmina and water samples
diet18 <- diet18 %>%
  filter(Class != "Syndiniales",
         SORTED_genus != "Water",
         SORTED_genus != "Bosmina")

# Put the Rhizaria classes into their own column to group them together for downstream analysis
rhizaria_classes <- c("Filosa-Thecofilosea", "Filosa-Sarcomonadea", 
                      "Filosa-Imbricatea", "Filosa-Chlorarachnea", 
                      "Filosa-Granofilosea", "Acantharea", "Polycystinea", 
                      "Endomyxa-Gromiidea", "Cercozoa_X", "Cercozoax")

# Group the low read abundant ciliates
ciliate_classes <-  c("Colpodea", "Heterotrichea",
                      "Ciliophora-10", "Ciliophora-5", "Ciliophorax")

# Do the same for the Opisthokonts
opistho_classes <-  c("Choanoflagellatea", "Choanoflagellidax", "Choanoflagellida_X")
                     
diet18 <- diet18 %>%
  mutate(PreyGroup = case_when(
    Class %in% rhizaria_classes ~ "Rhizaria",
    Class %in% ciliate_classes ~ "Other Ciliophora",
    Class %in% opistho_classes ~ "Opisthokonta",
    TRUE ~ Class
  ))



clean_df <- diet18 %>%
  select(Sample, Phylum, Class, Abundance, SORTED_genus, Location, PreyGroup)

# Calculate the relative abundance of the prey groups

diet18relative <- clean_df %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()           


```

# Diet analysis: combining the diet dataframes (+ abiotic) into one dataframe
```{r}
# Combine the 18S diet data with the 16S diet data and Syndiniales relative abundance composition (GLM_object.rds)

merged_diet <- merge(zoopl, diet18relative, by = c("Sample", "Location", "SORTED_genus")) # in this file the average of each parameter is the average of each measurement taken in that month. The syndiniales contributions within a host are in relative abundances.

# First overview of the diet data to see all is well with the taxa and the rel. ab calculations (should sum up to 1 for each sample)
ggplot(data = merged_diet,
       mapping = aes(x = Sample,             
                     y = RelativeAbundance,
                     fill = PreyGroup)) +        
  
  geom_bar(stat = "identity") +
  facet_grid(~Location + SORTED_genus,             
                                          scales = "free",
                                          space = "free") +
  scale_y_continuous(breaks = seq(0 , 1, .1))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Some samples don't have any data in them, --> remove them

merged_diet <- subset(merged_diet,!Sample%in%c("P19201_1034", "P12051_1226"))
merged_diet[is.na(merged_diet)] <- 0

# Plot again
ggplot(data = merged_diet,
       mapping = aes(x = Sample,             
                     y = RelativeAbundance,
                     fill = PreyGroup)) +        
  
  geom_bar(stat = "identity") +
  facet_grid(~Location + SORTED_genus,             
                                          scales = "free",
                                          space = "free") +
  scale_y_continuous(breaks = seq(0 , 1, .1))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Let's make the PreyGroup into separate columns to make plotting easier, ONLY the 18S data


# Make a summary so that each Sample + PreyGroup has ONE row
prey_summary <- merged_diet %>%
  group_by(Sample, PreyGroup) %>%
  summarise(RelativeAbundance = sum(RelativeAbundance), .groups = "drop")

# Pivot to wide format: PreyGroups as columns
prey_wide <- prey_summary %>%
  pivot_wider(names_from = PreyGroup,
              values_from = RelativeAbundance,
              values_fill = 0)

# Check that it looks right
glimpse(prey_wide)


# Get metadata (remove duplicates)
meta <- merged_diet %>%
  select(-PreyGroup, -RelativeAbundance) %>%
  distinct(Sample, .keep_all = TRUE)

# Merge back the wide prey data
final_table <- left_join(meta, prey_wide, by = "Sample")

```
# Correlation analysis, Fig 5

```{r}
df <- final_table

# make sure all the zeros are correct
df[is.na(df)] <- 0

# Changing the names of the columns
df <- df %>% rename(DinoI = "Dino-Group-I")
df <- df %>% rename(DinoII = "Dino-Group-II")
df <- df %>% rename(DinoIV = "Dino-Group-IV")



# Select only the parasite and diet columns (update these names if you want to add or remove some taxa!)
selected_columns <- c("DinoI", "DinoII", "DinoIV", 
                      "Dinophyceae", "Litostomatea", "Oligohymenophorea", "Opisthokonta", "Rhizaria", "Spirotrichea")  # Adjust names! "Diatom", "Picocyanobacteria", "Filamentous cyanobacteria", "Chlorophytes", "other Phytoplankton"
                                                                                                                                       # "Dinophyceae", "Litostomatea", "Oligohymenophorea", "Opisthokonta", "Rhizaria", "Spirotrichea"

filtered_df <- df %>% select(all_of(selected_columns))  # Select only relevant columns


# Histogram of one variable (change "Parasite1" to your variable name)
hist(filtered_df$DinoI, main = "Distribution of Parasite1", col = "skyblue")

# Shapiro-Wilk test for normality (p < 0.05 means NOT normal)
shapiro.test(filtered_df$DinoI)

library(corrplot)

# Compute correlation matrix. The data is not normally distributed -> we use spearman instead of pearson
cor_matrix <- cor(filtered_df, use = "pairwise.complete.obs", method = "spearman")

# Visualize the correlation matrix
corrplot(cor_matrix, method = "color", type = "upper", 
         tl.col = "black", tl.srt = 45, addCoef.col = "black",
         col = colorRampPalette(c("blue", "white", "red"))(200))

# Compute correlation with significance (looping over all pairs)
p_values <- cor.mtest(filtered_df, conf.level = 0.95)$p


# Bonferroni adjustment for the p value
p_values_adj <- matrix(p.adjust(p_values, method = "bonferroni"), 
                       nrow = nrow(p_values), 
                       ncol = ncol(p_values),
                       dimnames = dimnames(p_values))

# Plot heatmap with adjusted significance
corrplot(cor_matrix, method = "color", type = "upper",
         tl.col = "black", tl.srt = 45, addCoef.col = "black",
         col = colorRampPalette(c("blue", "white", "red"))(200),
         p.mat = p_values_adj, sig.level = 0.05)  # Uses Bonferroni-adjusted p-values



```

# Random Forest analysis, Fig 5

```{r}
# make the Syndiniales groups into response variables

# For 16S
prey_taxa <- c("Chlorophytes", "Diatom", "Picocyanobacteria", 
               "Filamentous cyanobacteria", "other Phytoplankton")


# For 18S
prey_taxa <- c("Dinophyceae", "Litostomatea", "Oligohymenophorea", 
               "Opisthokonta", "Rhizaria", "Spirotrichea")

prey_predictors <- df %>% select(all_of(prey_taxa))

dino_groups <- c("DinoI", "DinoII", "DinoIV")

for (dino in dino_groups) {
  response <- df[[dino]]
  rf_data <- data.frame(response = response, df %>% select(all_of(prey_taxa)))
  
  rf_model <- randomForest(response ~ ., data = rf_data, importance = TRUE)
  
  cat("\n==== Random Forest for", dino, "====\n")
  print(rf_model)
  varImpPlot(rf_model, main = paste("Variable Importance -", dino))
}



# Store results in a list
importance_list <- list()

for (dino in dino_groups) {
  response <- df[[dino]]
  rf_data <- data.frame(response = response, df %>% select(all_of(prey_taxa)))
  
  rf_model <- randomForest(response ~ ., data = rf_data, importance = TRUE)
  
  # Get importance (%IncMSE) and convert to data frame
  imp_df <- as.data.frame(importance(rf_model)[, "%IncMSE", drop = FALSE]) %>%
    rownames_to_column(var = "Prey_Taxon") %>%
    rename(Importance = `%IncMSE`) %>%
    mutate(Dino_Group = dino)
  
  importance_list[[dino]] <- imp_df
}

# Combine all into one dataframe
importance_all <- bind_rows(importance_list)
ggplot(importance_all, aes(x = reorder(Prey_Taxon, Importance), y = Importance, fill = Dino_Group)) +
  geom_col(position = "dodge") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Variable Importance by Dino Group (Random Forest)",
       x = "Prey Taxon",
       y = "% Increase in MSE (Importance)",
       fill = "Dino Group") +
  scale_fill_brewer(palette = "Set2")


```

# Filtering the data for pairwise comparirons

```{r}
# Keeping only the samples that have Syndiniales, removing the ones with no syndiniales reads

syndiniales_data <- all_samples %>%
  filter(Class == "Syndiniales",
         Abundance > 0)

# Calculate relative abundance of Syndiniales
syndiniales_data <- syndiniales_data %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done

# Filter out all but water

Water <- syndiniales_data %>%
  filter(SORTED_genus == "Water",)

Hosts <- all_syndiniales %>%
  filter(SORTED_genus != "Water")

# Calculate relative abundance of Supergroups
Hosts <- Hosts %>%
  group_by(Sample) %>%                              # Group by each sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()    

################################################################################

Temora <- syndiniales_data %>%
  filter(SORTED_genus == "Temora")

Acartia <- syndiniales_data %>%
  filter(SORTED_genus == "Acartia")

Centropages <- syndiniales_data %>%
  filter(SORTED_genus == "Centropages")

Pseudocalanus <- syndiniales_data %>%
  filter(SORTED_genus == "Pseudocalanus")

Water <- syndiniales_data %>%
  filter(SORTED_genus == "Water")

Evadne <- syndiniales_data %>%
  filter(SORTED_genus == "Evadne")

################################################################################

#Shapiro-Wilks for before the kruskal-wallis

shapiro_result <- shapiro.test(Pseudocalanus$RelativeAbundance) # Change the host/water


# Display the result
print(shapiro_result)

# Running Kruskal-Wallis Test for Location
kruskal.test(RelativeAbundance ~ Location, data = Pseudocalanus) ### Change the data to what you want to test, host/water
dunn_test_location <- dunnTest(RelativeAbundance ~ Location, data = Pseudocalanus, method = "bonferroni")
dunn_test_location


# Running Kruskal-Wallis Test for SAMPLE_strata 
kruskal.test(RelativeAbundance ~ SAMPLE_strata, data = Water) ### Change the data accordingly
dunn_test_depth <- dunnTest(RelativeAbundance ~ SAMPLE_strata, data = Water, method = "bonferroni")
dunn_test_depth




```

# Pairwise comparisons among the different syndiniales groups within a specific host

```{r}
# The different groups of syndiniales inside their hosts for kruskal wallis analyses

#Pseudocalanus

PseuIV <- Pseudocalanus %>%
  filter(Order == "Dino-Group-IV")

PseuI <- Pseudocalanus %>%
  filter(Order == "Dino-Group-I",)

PseuII <- Pseudocalanus %>%
  filter(Order == "Dino-Group-II")

PseuIII <- Pseudocalanus %>%
  filter(Order == "Dino-Group-III")

# Temora

TemIV <- Temora %>%
  filter(Order == "Dino-Group-IV")

TemI <- Temora %>%
  filter(Order == "Dino-Group-I")

TemII <- Temora %>%
  filter(Order == "Dino-Group-II")

TemIII <- Temora %>%
  filter(Order == "Dino-Group-III")


# Acartia

AcaIV <- Acartia %>%
  filter(Order == "Dino-Group-IV")

AcaI <- Acartia %>%
  filter(Order == "Dino-Group-I")

AcaII <- Acartia %>%
  filter(Order == "Dino-Group-II")

AcaIII <- Acartia %>%
  filter(Order == "Dino-Group-III")

# Centropages

CenIV <- Centropages %>%
  filter(Order == "Dino-Group-IV")

CenI <- Centropages %>%
  filter(Order == "Dino-Group-I")

CenII <- Centropages %>%
  filter(Order == "Dino-Group-II")

CenIII <- Centropages %>%
  filter(Order == "Dino-Group-III")

# Water

WaterIV <- Water %>%
  filter(Order == "Dino-Group-IV")

WaterI <- Water %>%
  filter(Order == "Dino-Group-I")

WaterII <- Water %>%
  filter(Order == "Dino-Group-II")

WaterIII <- Water %>%
  filter(Order == "Dino-Group-III")

# Access the "Abundance" column and perform the Shapiro-Wilk test
shapiro_result <- shapiro.test(WaterI$RelativeAbundance)


# Display the result
print(shapiro_result)

# Running Kruskal-Wallis Test for Location
kruskal.test(RelativeAbundance ~ Location, data = WaterIV) ### Change the data to what you want to test

dunn_test_location <- dunnTest(RelativeAbundance ~ Location, data = WaterI, method = "bonferroni")
dunn_test_location

# Running Kruskal-Wallis Test for SAMPLE_strata ####################################
kruskal.test(RelativeAbundance ~ SAMPLE_strata, data = WaterIV) ### Change the data accordingly
dunn_test_depth <- dunnTest(RelativeAbundance ~ SAMPLE_strata, data = WaterIV, method = "bonferroni")
dunn_test_depth
```
# Figure S3
```{r}
zoopl_long <- zoopl %>%
  pivot_longer(
    cols = 19:24,  # your taxa columns
    names_to = "Taxa",
    values_to = "RelAbundance"
  ) 


zoopl_avg <- zoopl_long %>%
  group_by(Location, SAMPLE_strata, visit_year, SORTED_genus, Taxa) %>%
  summarise(mean_relAbundance = mean(RelAbundance, na.rm = TRUE), .groups = "drop")

# Plot it
ggplot(data = zoopl_avg,
       mapping = aes(x = Location,             
                     y = mean_relAbundance,
                     fill = Taxa)) +        # Taxa represents the diet component groups
  
  geom_bar(stat = "identity") +
  facet_grid(~ Location+ SORTED_genus +SAMPLE_strata + visit_year,             # SAMPLE_strata to see the different depths in BY31
             scales = "free",
             space = "free") +
  scale_y_continuous(breaks = seq(0 , 1, .1))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  scale_fill_manual(values = c("hotpink","#99CC66", "#0099FF", "#FF9900","#CC6633","#FFCC33"))



```


# Figure S4

```{r}

Watertot <- all_samples %>%
  filter(SORTED_genus == "Water") 
Acatot <- all_samples %>%
  filter(SORTED_genus == "Acartia") 
Pseutot <- all_samples %>%
  filter(SORTED_genus == "Pseudocalanus") 
Centot <- all_samples %>%
  filter(SORTED_genus == "Centropages") 
Temoratot <- all_samples %>%
  filter(SORTED_genus == "Temora") 
Evadnetot <- all_samples %>%
  filter(SORTED_genus == "Evadne") 

# Calculate relative abundance of the Alveolata classes within each of the locations

Community <- Temoratot %>% # Change the host/water here
  group_by(Sample) %>%                              # Group by each Sample
  mutate(RelativeAbundance = Abundance / sum(Abundance)) %>% # Compute relative abundance
  ungroup()                                        # Ungroup when done


#Plot the water community composition

ggplot(data = Community,                                             # Change the taxa/water you want to plot e.g., Temora, Acartia etc.
       mapping = aes(x = Sample,  # To show variation between the samples
                     y = RelativeAbundance,
                     fill = Supergroup)) +
  geom_bar(stat = "identity") +
  ## then you can add some aestetics
  
  facet_grid(.~ SORTED_genus + SAMPLE_date + Location,        #here you choose which factors you want to see in the plot e.g., add SAMPLE_strata
             scales = "free_x",
             space = "free") +
  labs(x =NULL,
       y = "Proportion of Syndiniales groups") +
  scale_y_continuous(breaks = seq(0 , 1, .25))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5)) +
  
  scale_fill_manual(values = c("Alveolata" = "moccasin",  
                               "Opisthokonta" = "lightblue",
                               "Rhizaria" = "navy",
                               "Stramenopiles" = "forestgreen",
                               "Eukaryotax" = "tomato",
                               "Archaeplastida" = "pink",
                               "Hacrobia" = "orange",
                               "Excavata" = "orchid",
                               "Amoebozoa" = "lightgrey"))

```

